![[golden_gate_bridge.png]]
## Golden Measure
- A sequential solution that you develop as the yard stick
- A solution that may run slowly, isn't optimised but you know it gives (numerically speaking) excellent results
- Its not about computation time but accuracy
## Sequential / Serial
A non-parallelized code solution
## Speed-up
- $\text{Speed-up} = \frac{T_{p1}}{T_{p2}}$ . $T_{p1}$ = run-time of original (or non-optimized) program
- $T_{p2}$ = run-time of optimised prograam
- Best practise: run the program more than once so as to warm up the system


12/03/2024
## Verification and Validation (V&V)
- Verification (dev end)
  - “Are we building the product right?”
  - Have we made what we understood we wanted to make?
  - Does the product satisfy its specifications?
- Validation (user end)
  - “Are we building the right product?”
  - Does the product satisfy the users’ requirements
- Verification before validation (at least in duress)…
While it would be nice to validate (seeing that the users are happy) before verifying (checking the specs), doing so would mean your final design might not match the specifications (which could open the door to legal problems). Obviously this often doesn’t happen because in practice you want to make sure the client is happy and there might not be time for proper validation.
## Verification before validation
- The RC engineer (i.e., you) are effectively designing both custom hardware and custom
software for the RC platform
- Before attempting to make claims about the validity of your system, it’s usually best practice to establish your own (or team’s) confidence in what your system is doing, i.e. be sure that:
  - The custom hardware working;
  - The software implementation is doing what it was designed to do; and
  - The custom software runs reliably on the custom hardware.
## Verification
- Checking plans, documents, code, requirements and specifications
- Is everything that you need there?
- Algorithms/functions working properly?
- Done during phase interval (e.g., design => implementation)
- Activities:
  - Review meetings, walkthroughs, inspections
  - Informal demonstrations
## Commonly used verification methods
1. Dual processing, producing two result sets
  1. One version using PC & simulation only;
  2. Other version including RC platform
2. Assume the PC version is the correct one (i.e., the gold measure)
3. Correlate the results to establish correlation coefficients
(complex systems may have many different sets of possibly multidimensional data that need to be compared)
The correlation coefficients can be used as a kind of ‘confidence factor’
## Validation
- Testing of the whole product / system
- Input: checklist of things to test or list of issues that need to have been provided/fixed
- Towards end of project
- Activities:
  - Formal demonstrations
  - Factory Acceptance Test
## Testing and Correctness proofs
- Testing
  - Generally refers to aspects of dynamic validation in which a program is executed and the results analysed
- Correctness proofs / formal verification
  - More a mathematical approach
  - Exhaustive test => specification guaranteed correct
  - Formal verification of hardware is especially relevant to RC. Formal methods include:
    -Model checking / state space exploration
    -Use of linear temporal logic and computational tree logic
    -Mathematical proof (e.g. proof by induction)
## Amdahl’s Law Insert graph on page 15 here

## Essentials of Amdahl’s Law
- Be aware that a computer program to run on a parallel computer * pretty much always has a part that is sequential, which can run on only one core, and a part that is parallel, that can be split between available cores
- But, let’s make things more fun (and hope you then understand Amdahl’s better) by proceeding to video linked on next slide.
- Comments on slide 19 elaborates further.
*well, we’re thinking here computers with one or more CPUs for their processing

## Amdahl’s Law
- Define f as: fraction of computation that can be parallelized (ignoring scheduling overhead)
- Then (1 -f ) is the fraction that is sequential
- Define n = no. processors for parallel case
- The maximum speed-up achievable is:
$$
\text{Speedup}_\text{parallel} = \frac{1}{(1-f)+\frac{f}{n}}
$$
Should be able to remember this formula for exams
### Alternate Representation
P = expected performance improvement
$E^u$ = Execution time on a uniprocessor (serial)
$E^p$ = Execution time on a number of processors (parallel)
n = number of processors
S = fraction of time spent in the sequential time
$$
P = \frac{E^u}{E^p} = \frac{E^u}{SE^u+\frac{(1-s)}{N}E^u} = \frac{1}{s+\frac{1-S}{N}}
$$




Understanding Parallel Computing (Part 2): The Lawn Mower Law
LinuxMagazine
YODA Project Topics
Call for
PROPOSALS
now open!
New link added soon
Current projects listing:
To submit your own proposal
please using this structure and
send to me as an email:
Pxx: <acronym> - <proj title>
<brief overview>
<possibly code snippet to explain the
algorithm is relevant>
<any added wishlist/upgrade items>
Inputs: <interface to your module>
Outputs: < interface out of your module >
The focus is around a Verilog module you would implement, but
that module needs to be hooked up to the carrying system
Prelude towards YODA project with is more a Term 2 activity
An example YODA Project
Topic: SALG - Selection Address List Generator
• SALG sent starting address of a table in memory.
• Table has n elements.
• Each element of the table is in the form TableElement below.
• The SALG is sent a second address, inds, use to store the
addresses (i.e., the starting address of the relevant record field)
that matches the selection criteria (which is hardcoded).
struct TableElement{
unsigned key;
byte record[rsize];
};
TableElement table[n];
void SALGA(TableElement* table,
unsigned* inds, unsigned n){
unsigned n_inds = 0;
for (int i = 0; i < n; i++) {
if (table[n]->key & 1)
inds[n_inds++] =
&table[n]->record[0];
}
inds[n_inds] = 0; // set last one to null to indicate end of list
}
Choose your own selection criteria
Prelude towards YODA project with is more a Term 2 activity
Soon over to Prac1!
theory issues practical issues
Image source: https://creativecommons.org/publicdomain/zero/1.0/
closing
remarks & reminders…
Dealing with reading assignments
- You are suppose to read (at least speed
read) the readings assigned as
recommended – the others are more for
deepening your insights into an area
open("L01 Berkeley 2006 - Landscale of
Parallel Computing Research.pdf") do pg1-8
… you might need to do more readings than that
Assigned Reading
For Tuesday next week…
S1 - Landscape of parallel computing
research: a view from Berkeley
Find it in: Abathuba / Readings
listed in Readings resources
There will be a short quiz, and I will follow that with solutions
and a short seminar on the paper to explain its highlights.
This paper is usually in the final exam syllabus.
End of Lecture 2
FREE Creative Commons License
JAZZY FRENCHY
Music: https://www.bensound.com
Image sources:
Wikipedia (open commons)
http://www.flickr.com
http://pixabay.com/
https://publicdomainvectors.org
Disclaimers and copyright/licensing details
I have tried to follow the correct practices concerning copyright and licensing of material,
particularly image sources that have been used in this presentation. I have put much
effort into trying to make this material open access so that it can be of benefit to others in
their teaching and learning practice. Any mistakes or omissions with regards to these
issues I will correct when notified. To the best of my understanding the material in these
slides can be shared according to the Creative Commons “Attribution-ShareAlike 4.0
International (CC BY-SA 4.0)” license, and that is why I selected that license to apply to
this presentation (it’s not because I particulate want my slides referenced but more to
acknowledge the sources and generosity of others who have provided free material such
as the images I have used).
