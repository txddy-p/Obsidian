![[golden_gate_bridge.png]]
## Golden Measure
- A sequential solution that you develop as the yard stick
- A solution that may run slowly, isn't optimised but you know it gives (numerically speaking) excellent results
- Its not about computation time but accuracy
## Sequential / Serial
A non-parallelized code solution
## Speed-up
- $\text{Speed-up} = \frac{T_{p1}}{T_{p2}}$ . $T_{p1}$ = run-time of original (or non-optimized) program
- $T_{p2}$ = run-time of optimised prograam
- Best practise: run the program more than once so as to warm up the system


12/03/2024
## Verification and Validation (V&V)
- Verification (dev end)
  - “Are we building the product right?”
  - Have we made what we understood we wanted to make?
  - Does the product satisfy its specifications?
- Validation (user end)
  - “Are we building the right product?”
  - Does the product satisfy the users’ requirements
- Verification before validation (at least in duress)…
While it would be nice to validate (seeing that the users are happy) before verifying (checking the specs), doing so would mean your final design might not match the specifications (which could open the door to legal problems). Obviously this often doesn’t happen because in practice you want to make sure the client is happy and there might not be time for proper validation.
## Verification before validation
- The RC engineer (i.e., you) are effectively designing both custom hardware and custom
software for the RC platform
- Before attempting to make claims about the validity of your system, it’s usually best practice to establish your own (or team’s) confidence in what your system is doing, i.e. be sure that:
  - The custom hardware working;
  - The software implementation is doing what it was designed to do; and
  - The custom software runs reliably on the custom hardware.
## Verification
- Checking plans, documents, code, requirements and specifications
- Is everything that you need there?
- Algorithms/functions working properly?
- Done during phase interval (e.g., design => implementation)
- Activities:
  - Review meetings, walkthroughs, inspections
  - Informal demonstrations
## Commonly used verification methods
1. Dual processing, producing two result sets
  1. One version using PC & simulation only;
  2. Other version including RC platform
2. Assume the PC version is the correct one (i.e., the gold measure)
3. Correlate the results to establish correlation coefficients
(complex systems may have many different sets of possibly multidimensional data that need to be compared)
The correlation coefficients can be used as a kind of ‘confidence factor’
## Validation
- Testing of the whole product / system
- Input: checklist of things to test or list of issues that need to have been provided/fixed
- Towards end of project
- Activities:
  - Formal demonstrations
  - Factory Acceptance Test
## Testing and Correctness proofs
- Testing
  - Generally refers to aspects of dynamic validation in which a program is executed and the results analysed
- Correctness proofs / formal verification
  - More a mathematical approach
  - Exhaustive test => specification guaranteed correct
  - Formal verification of hardware is especially relevant to RC. Formal methods include:
    -Model checking / state space exploration
    -Use of linear temporal logic and computational tree logic
    -Mathematical proof (e.g. proof by induction)
## Amdahl’s Law Insert graph on page 15 here

## Essentials of Amdahl’s Law
- Be aware that a computer program to run on a parallel computer * pretty much always has a part that is sequential, which can run on only one core, and a part that is parallel, that can be split between available cores
- But, let’s make things more fun (and hope you then understand Amdahl’s better) by proceeding to video linked on next slide.
- Comments on slide 19 elaborates further.
*well, we’re thinking here computers with one or more CPUs for their processing

## Amdahl’s Law
- Define f as: fraction of computation that can be parallelized (ignoring scheduling overhead)
- Then (1 -f ) is the fraction that is sequential
- Define n = no. processors for parallel case
- The maximum speed-up achievable is:
$$\text{Speedup}_\text{parallel} = \frac{1}{(1-f)+\frac{f}{n}}$$
Should be able to remember this formula for exams
### Alternate Representation
P = expected performance improvement
$E^u$ = Execution time on a uniprocessor (serial)
$E^p$ = Execution time on a number of processors (parallel)
n = number of processors
S = fraction of time spent in the sequential time
$$P = \frac{E^u}{E^p} = \frac{E^u}{SE^u+\frac{(1-s)}{N}E^u} = \frac{1}{s+\frac{1-S}{N}}$$
