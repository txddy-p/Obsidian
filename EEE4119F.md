# Lecture 1:Numerical Integration
- Initial condition is crucial:
## Euler Method
### Euler Algorithm
- We generally want to take small increments (âˆ†ğ‘¡), so:
$$
y_n = y_{n-1} + \frac{dy}{dt}\Bigr\rvert_{t = 0}\Delta t
$$
## Taylor Series
- Consider an arbitrary function (y)
- We can make an approximation:
$$
\hat{y} = a +bt +ct^2 + dt^3 + ...
$$
- Solve for coefficients
- Simplest approximation would be to use derivative:
$$
\hat{y} = y(t=0) + \frac{dy}{dt}\Bigr\rvert_{t = 0}t
$$
- We can make this better with second derivative:
$$\text{put formula on page 16 of lecture 1 slides}$$
- Add more derivatives:
$$\text{formula on page 16 of lecture 1 slides}$$
- Called Taylor Series
### Error Analysis
- Initial value problem:
Euler method
Error term
- Only need to care about first term
- Why?
- Error scales with âˆ†ğ’•
- If we half âˆ†ğ’• , then we half the error!
Euler Error
## Midpoint Method Error
- Extrapolation based on midpoint gradient:
- Exactly Taylor approximation of y for first three terms
	- Much more accurate than Euler!
- Letâ€™s use Euler:
$$y_{N+\frac{1}{2}} = y_N + \frac{\Delta t}{2}\frac{dy}{dt}\Bigr\rvert_{N}$$
- Then using $y_{N+\frac{1}{2}}$ and $\frac{\Delta{t}}{2}$ , can calculate the derivative
- Last step in algorithm is then:
$$
y_{N+1} = y_N + \Delta{t}\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}
$$
### Midpoint Method Steps
- `Step1: Euler`   $y_{N+\frac{1}{2}} = y_N + \frac{\Delta t}{2}\frac{dy}{dt}\Bigr\rvert_{N}$
- `Step2: Deriv`   $\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}$
- `Step3: Shoot to end`: $y_{N+1} = y_N + \Delta{t}\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}$
## Runge-Kutta Method
- Instead of shooting to midpoint, shoot to 4 specific points
- RK4 Algorithm
Assume: $\frac{d{y}}{d{t}} = f(y,t)$
Then:
$$
\begin{align*}
k_1 &= \Delta{t}f\left ( y_N, t_N \right )\\
k_2 &= \Delta{t}f\left ( y_N + \frac{k_1}{2}, t_N + \frac{\Delta{t}}{2} \right )\\
k_3 &= \Delta{t}f\left ( y_N + \frac{k_2}{2}, t_N + \frac{\Delta{t}}{2} \right )\\
k_4 &= \Delta{t}f\left ( y_N + k_3, t_N + \Delta{t} \right )\\
y_{N+1} &= y_N + \frac{1}{6} \left ( k_1 +2k_2 +2k_3 +k4 \right )
\end{align*}
$$
# Lecture 2:Lagrange Mechanics I
- Consider ğ‘µ particles
	- Can describe configuration as: $p_N = [x_N y_N z_N]^T$
- Most times, there are constraintsâ€¦
- Can then describe configuration using less parameters (ğ‘› â‰¤ 3ğ‘)
- DOF = n - m
	- ğ‘š is number of constraint equations
## Kinetic Energy
- Total Kinetic Energy of system (ğ‘‡)
- For point particles:
$$
T = \frac{1}{2}\sum_{i=1}^{N}m_i\dot{r}_i^{2}
$$
- What about rigid bodies?
	- Include rotational energy & inertias
$$
T = \frac{1}{2}\sum_{i=1}^{N}m_i\dot{r}_i^{2} + \frac{1}{2}\sum_{i=1}^N I\omega_i^2
$$
## Potential Energy
- Potential Energy from Gravity ($V_{grav}$)
$$V = \sum_{i=1}^{N}m_igh_i$$
- Potential Energy from springs ($V_s$)
$$V = \frac{1}{2}\sum_{i=1}^{N}k_ix_i^{2}$$
## The Lagrangian
$$
L(q,\dot{q}) = T(q,\dot{q}) - V(q)
$$
### Dynamic equation for coordinate $q_i$
$$
\frac{d}{dt}\left ( \frac{\partial L}{\partial \dot{q_i}} \right ) - \frac{\partial L}{\partial {q_i}} = 0
$$
- Repeat for all ğ‘–
- The above gives the EOM for the body
# Lecture 3: Lagrange Mechanics II
- Multibody Systems
## Constraints Revisited
$$\text{DOF} = 3N - m$$
- ğ‘µ is number of bodies and ğ’ is number of constraints
## Multibody systems
- Multibody systems involve multiple rigid bodies
- Each with own COM
- In Lagrange, donâ€™t care about reaction forces or constraint equations
-  Just need to define energy of COM
## Manipulator Equation
- Lagrange EOM are straightforward but tedious to calculate
- Quick side note on motors
$$\frac{d}{dt}\left ( \frac{\partial L}{\partial \dot{q_i}}  \right ) - \frac{\partial L}{\partial q_i} = \tau_i$$
Manipulator Equation
$$
M(q)\ddot{q} + C(q,\dot{q}) + G(q) = \tau
$$
- M = ğ’ Ã— ğ’ Mass Matrix
- C = velocity-product matrix
- G = Gravity term
- $\tau$ = Joint torques

# Lecture 4:3D Kinematics
## Rotating Axes
- consider vector p
- In axes 0 
$$p^0 = \begin{bmatrix}   p_x^0\\   p_y^0   \end{bmatrix}$$
- In axes 1 (rotated by $\psi$) (CCW)
$$
p^0 = \begin{bmatrix}   p_x^1\\   p_y^1   \end{bmatrix}
$$
### Changing axes
$$
\begin{align*}
p^1 &= R_0^1p^0\\
R_0^1 &= \left [ R_1^0 \right ]^{-1}\\
R_0^1 &= \left [ R_1^0 \right ]^{T}
\end{align*}
$$
- Because R is othorgonal you can just take the transpose
## Successive Rotations
Any rigid body attitude can be represented by three rotations. Eg:
### $$R_{x^2,\phi}R_{y^1,\theta}R_{z^0,\psi}$$
- Things to take note of:
	- Rotation is about the new axes
	- Rotation order starts from the right
- Resultant matrix called:
	- Direction Cosine Matrix (DCM)
## Euler Angles
- Euler angles represent attitude about using three numbers:$\textbf{u} = [\phi \hspace{5mm}\theta \hspace{5mm}\psi]^T$
- Need to specify the order
	- Eg. Euler 3-2-1 is
	- Rot about Z, then Y and the X
## Angular Velocity
- Can only add angular velocity vectors in same axis!
- Cannot directly add Euler angle rates ($\dot{\textbf{u}}$) to get $\omega_{Total}$
- We want (inertial): $\omega_T^I = E\dot{u}$
- Or (Body):$\omega_T^B = E'\dot{u}$
## Euler Rates Matrix (E)
- Eg: If we use Euler 3-2-1, E is given by: 
$$
E_{321} = \left [ [R_Z]^T[R_Y]^T\hat{e}_X, [R_Z]^T\hat{e}_Y, \hat{Z} \right ]
$$
- Total angular velocity in Inertial Frame:
$$
\omega_T^I =E\begin{bmatrix}
\dot{\phi} \\
\dot{\theta} \\
\dot{\psi}
\end{bmatrix}
$$
# Lecture 4:
3D Dynamics
â€¢ Kinetic Energy
â€¢ Potential Energy
Overview
ABB Robot Arms
Mini Cheetah
Exercise: Two Axis Gimbalx0
y0
z0
Ï†
Î¸
x1
y1
z1
Rotation order:
1. Rotation about X
2. Rotation about Y
Task
â€¢ Derive DCM (ğ‘¹ğŸ
ğŸ)
â€¢ Derive Euler Rate Matrix
Exercise: Two Axis Gimbalx0
y0
z0
Ï†
Î¸
x1
y1
z1
*Assume origin of all axes aligned
ğ‘…0
1 =
ğ‘ğ‘œğ‘ ğœƒ 0 âˆ’ğ‘ ğ‘–ğ‘›ğœƒ
0 1 0
ğ‘ ğ‘–ğ‘›ğœƒ 0 ğ‘ğ‘œğ‘ ğœƒ
1 0 0
0 ğ‘ğ‘œğ‘ ğœ‘ ğ‘ ğ‘–ğ‘›ğœ‘
0 âˆ’ğ‘ ğ‘–ğ‘›ğœ‘ ğ‘ğ‘œğ‘ ğœ‘
ğ‘…0
1 =
ğ‘ğ‘œğ‘ ğœƒ ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ ğ‘–ğ‘›ğœƒ âˆ’ğ‘ğ‘œğ‘ ğœ‘ğ‘ ğ‘–ğ‘›ğœƒ
0 ğ‘ğ‘œğ‘ ğœ‘ ğ‘ ğ‘–ğ‘›ğœ‘
ğ‘ ğ‘–ğ‘›ğœƒ âˆ’ğ‘ğ‘œğ‘ ğœƒğ‘ ğ‘–ğ‘›ğœ‘ ğ‘ğ‘œğ‘ ğœ‘ğ‘ğ‘œğ‘ ğœƒ
DCM
Exercise: Two Axis Gimbalx0
y0
z0
Ï†
Î¸
x1
y1
z1
Euler Rate Matrix ğğ‘‡
0 = ğ‘¬ áˆ¶ ğœ‘
áˆ¶
ğœƒ
ğ‘¬ğŸğŸ = à·œğ’†ğ‘¿ ğ‘¹ğ‘¿ ğ‘» à·œğ’†ğ’€,
ğ‘¹ğ‘¿ ğ‘» à·œğ’†ğ’€ =
1 0 0
0 ğ‘ğ‘œğ‘ ğœ‘ ğ‘ ğ‘–ğ‘›ğœ‘
0 âˆ’ğ‘ ğ‘–ğ‘›ğœ‘ ğ‘ğ‘œğ‘ ğœ‘
ğ‘‡
0
1
0
=
0
ğ‘ğ‘œğ‘ ğœ‘
ğ‘ ğ‘–ğ‘›ğœ‘
ğ‘¬ğŸğŸ =
1 0
0 ğ‘ğ‘œğ‘ ğœ‘
0 ğ‘ ğ‘–ğ‘›ğœ‘
Translational Kinetic Energy
â€¢ Kinetic Energy
â€¢ Potential Energy
Lecture 4:
3D Dynamics
â€¢ Translation portion straightforward
â€¢ With:
ğ‘‡ğ‘¡ = 1
2 ğ’ áˆ¶ ğ’“ğ‘» áˆ¶ ğ’“
áˆ¶
ğ’“ = ğ‘‘
ğ‘‘ğ‘¡ ğ‘«ğ‘ªğ‘´ ğ‘»ğ’“ğŸ
Moment of Inertia (3D)
Inertia about an arbitrary axis:
Eg. Rotation about X-axis:
Total inertia: ğ¼ =
ğ¼ğ‘¥ğ‘¥ ğ¼ğ‘¦ğ‘¥ ğ¼ğ‘§ğ‘¥
ğ¼ğ‘¦ğ‘¥ ğ¼ğ‘¦ğ‘¦ ğ¼ğ‘§ğ‘¦
ğ¼ğ‘§ğ‘¥ ğ¼ğ‘¦ğ‘§ ğ¼ğ‘§ğ‘§
Off diagonals:
Total Angular Velocity
â€¢ Using the inertia: ğ‘»ğ’“ = ğŸ
ğŸ ğğŸ ğ‘»ğ‘°ğŸğğŸ
â€¢ Problem!
â€¢ Moment of Inertia wrt to 0 (inertial)
â€¢ It will change as a function of orientation as the
body rotates
â€¢ Solution?
â€¢ Define Inertia in body axis
â€¢ Will be constant as the body rotates wrt 0
Total Angular Velocity
â€¢ Using the body inertia:
ğ‘»ğ’“ = ğŸ
ğŸ ğğ‘© ğ‘»ğ‘°ğ‘©ğğ‘©
Constant matrix
â€¢ ğğ‘© is total angular velocity of body in body axes
â€¢ Relating inertias: ğ‘°ğŸ = ğ‘¹ğ‘©
ğŸ ğ‘°ğ‘©
Potential Energy
â€¢ Kinetic Energy
â€¢ Potential Energy
Lecture 4:
3D Dynamics
â€¢ Assume all gravity for now
â€¢ With:
ğ‘‰ğ‘” = ğ’ ğ’ˆğŸ ğ‘»ğ’“ğŸ
ğ’ˆğŸ =
0
0
ğ‘”
Local gravitational
acceleration
Example: Acrobot
Rotation Matrices:
ğ‘¹ğŸ
ğŸ =
ğ‘ğ‘œğ‘ ğœƒ1 ğ‘ ğ‘–ğ‘›ğœƒ1 0
âˆ’ğ‘ ğ‘–ğ‘›ğœƒ1 ğ‘ğ‘œğ‘ ğœƒ1 0
0 0 1
ğ‘¹ğŸ
ğŸ =
ğ‘ğ‘œğ‘ ğœƒ2 ğ‘ ğ‘–ğ‘›ğœƒ2 0
âˆ’ğ‘ ğ‘–ğ‘›ğœƒ2 ğ‘ğ‘œğ‘ ğœƒ2 0
0 0 1
ğ‘¹ğŸ
ğŸ = ğ‘¹ğŸ
ğŸğ‘¹ğŸ
ğŸ
Positions:
ğ’“ğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ ğ‘»ğ’“ğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ ğ‘»
ğ¿1
2
0
0
ğ’“ğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ ğ‘» ğ¿1
0
0
+ ğ‘¹ğŸ
ğŸ ğ‘»ğ’“ğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ ğ‘» ğ¿1
0
0
+ ğ‘¹ğŸ
ğŸ ğ‘»
ğ¿2
2
0
0Î¸1
Ï„2
Î¸2
L1
x0
y0 1
2
0
Example: Acrobot
Angular Velocity:
ğğŸğŸ
ğŸ =
0
0
áˆ¶
ğœƒ1
ğğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ
0
0
áˆ¶
ğœƒ1
+
0
0
áˆ¶
ğœƒ2
ğğŸğŸ
ğŸ =
0
0
áˆ¶
ğœƒ1 + áˆ¶ ğœƒ2Î¸1
Ï„2
Î¸2
L1
x0
y0 1
2
0
Example: Quadcopter gimbal
â€¢ Euler 3-2-1 for quad body
â€¢ Generalised coordinates?
ğ’’ = ğ‘¥ ğ‘¦ ğ‘§ ğœ‘1 ğœƒ1 ğœ“1 ğœ‘2 ğœƒ2 ğ‘‡x0
y0
z0
Exercise: Quadcopter gimbal
â€¢ Quad Angular Velocity
ğğŸğŸ
ğŸ = ğ‘¬ğ‘¸ğŸ
â€²
áˆ¶
ğœ‘1
áˆ¶
ğœƒ1
áˆ¶
ğœ“1
ğ‘¬ğ‘¸ğŸ
â€² = à·œğ’†ğ‘¿, ğ‘¹ğ‘¿ à·œğ’†ğ’€, ğ‘¹ğ‘¿ğ‘¹ğ’€ à·œğ’†ğ’x0
y0
z0
Exercise: Quadcopter gimbal
â€¢ Camera Angular Velocity
ğğŸğŸ
ğŸ = ğğŸğŸ
ğŸ + ğğŸğŸ
ğŸ
ğ‘¬ğ‘¸ğŸ
â€² = ğ‘¹ğ’€ğ‘¹ğ‘¿ à·œğ’†ğ‘¿, ğ‘¹ğ’€ğ‘¹ğ‘¿ğ‘¹ğ‘¿ à·œğ’†ğ’€, ğ‘¹ğ’€ğ‘¹ğ‘¿ğ‘¹ğ‘¿ğ‘¹ğ’€ à·œğ’†ğ’
ğğŸğŸ
ğŸ = ğ‘¬ğ‘¸ğŸ
â€²
áˆ¶
ğœ‘1
áˆ¶
ğœƒ1
áˆ¶
ğœ“1x0
y0
z0
Exercise: Puma 560
â€¢ Determine Kinetic
Energy of the
gripperx0
y0
z0
â€¢ Roll(Y)â†’Pitch(X)â†’Yaw(Z)
Kinematic Chainx2
y1
z1
x0
y0
z0
z2
z3
z4
x3
x4
x1
y2
y3
y4
Ïˆ1
Ï†2
Ï†3
Ï†4,Î¸4,Ïˆ4
â€¢ What is ğ‘¹ğŸ
ğŸ’?
ğ‘¹ğŸ
ğŸ’ = ğ‘¹ğŸ‘
ğŸ’ğ‘¹ğŸ
ğŸ‘ğ‘¹ğŸ
ğŸğ‘¹ğŸ
ğŸ
â€¢ What is ğ‘¹ğŸ‘
ğŸ’?
ğ‘¹ğŸ‘
ğŸ’ =
ğ‘ğ‘œğ‘ ğœ“4 ğ‘ ğ‘–ğ‘›ğœ“4 0
âˆ’ğ‘ ğ‘–ğ‘›ğœ“4 ğ‘ğ‘œğ‘ ğœ“4 0
0 0 1
1 0 0
0 ğ‘ğ‘œğ‘ ğœ‘4 ğ‘ ğ‘–ğ‘›ğœ‘4
0 âˆ’ğ‘ ğ‘–ğ‘›ğœ‘4 ğ‘ğ‘œğ‘ ğœ‘4
ğ‘ğ‘œğ‘ ğœƒ4 0 âˆ’ğ‘ ğ‘–ğ‘›ğœƒ4
0 1 0
ğ‘ ğ‘–ğ‘›ğœƒ4 0 ğ‘ğ‘œğ‘ ğœƒ4
YXZ
Angular Velocity
â€¢ What is ğğŸğŸ’
ğŸ’ ?x2
y1
z1
x0
y0
z0
z2
z3
z4
x3
x4
x1
y2
y3
y4
Ïˆ1
Ï†2
Ï†3
Ï†4,Î¸4,Ïˆ4
ğğŸğŸ’
ğŸ’ = ğğŸğŸ
ğŸ’ + ğğŸğŸ
ğŸ’ + ğğŸğŸ‘
ğŸ’ + ğğŸ‘ğŸ’
ğŸ’
ğğŸğŸ
ğŸ’ = ğ‘¬ğŸ
â€² áˆ¶ ğœ“1,
ğ‘¬ğŸ
â€² = ğ‘¹ğ’ğ‘¹ğ‘¿ğ‘¹ğ’€ğ‘¹ğŸ
ğŸ‘ğ‘¹ğŸ
ğŸ à·œğ’†ğ’
ğ‘¹ğŸ‘
ğŸ’
ğ‘¬ğŸ
â€² = ğ‘¹ğ’ğ‘¹ğ‘¿ğ‘¹ğ’€ğ‘¹ğŸ
ğŸ‘ à·œğ’†ğ‘¿ ğ‘¬ğŸ‘
â€² = ğ‘¹ğ’ğ‘¹ğ‘¿ğ‘¹ğ’€ à·œğ’†ğ‘¿
ğğŸğŸ
ğŸ’ = ğ‘¬ğŸ
â€² áˆ¶ ğœ‘2, ğğŸğŸ‘
ğŸ’ = ğ‘¬ğŸ‘
â€² áˆ¶ ğœ‘3, ğğŸ‘ğŸ’
ğŸ’ = ğ‘¬ğŸ’
â€²
áˆ¶
ğœ‘4
áˆ¶
ğœƒ4
áˆ¶
ğœ“4
Easier way?
ğ‘¹ğŸ
ğŸ’ ğğŸğŸ’
ğŸ’
â€¢ It would be great if we could just use the final rotation
matrix: Some magic
â€¢ We can!
Skew Symmetric Property
â€¢ R. M. Murray, Z. Li, and S. S. Sastry, A Mathematical
Introduction to Robotic Manipulation. CRC Press, 1994.
(Chapter 4.1)
ğğ‘© Ã— = ğ‘¹ğ‘©
ğ‘° ğ‘» áˆ¶ ğ‘¹ğ‘©
ğ‘° = ğ‘º
ğğ‘© Ã— =
0 âˆ’ğœ”3 ğœ”2
ğœ”3 0 âˆ’ğœ”1
âˆ’ğœ”2 ğœ”1 0
The end.
â€¢ Next lecture:
â€¢ Generalised
forces