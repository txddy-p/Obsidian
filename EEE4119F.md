# Lecture 1:Numerical Integration
- Initial condition is crucial:
## Euler Method
### Euler Algorithm
- We generally want to take small increments (âˆ†ğ‘¡), so:
$$
y_n = y_{n-1} + \frac{dy}{dt}\Bigr\rvert_{t = 0}\Delta t
$$
## Taylor Series
- Consider an arbitrary function (y)
- We can make an approximation:
$$
\hat{y} = a +bt +ct^2 + dt^3 + ...
$$
- Solve for coefficients
- Simplest approximation would be to use derivative:
$$
\hat{y} = y(t=0) + \frac{dy}{dt}\Bigr\rvert_{t = 0}t
$$
- We can make this better with second derivative:
$$\text{put formula on page 16 of lecture 1 slides}$$
- Add more derivatives:
$$\text{formula on page 16 of lecture 1 slides}$$
- Called Taylor Series
### Error Analysis
- Initial value problem:
Euler method
Error term
- Only need to care about first term
- Why?
- Error scales with âˆ†ğ’•
- If we half âˆ†ğ’• , then we half the error!
Euler Error
## Midpoint Method Error
- Extrapolation based on midpoint gradient:
- Exactly Taylor approximation of y for first three terms
	- Much more accurate than Euler!
- Letâ€™s use Euler:
$$y_{N+\frac{1}{2}} = y_N + \frac{\Delta t}{2}\frac{dy}{dt}\Bigr\rvert_{N}$$
- Then using $y_{N+\frac{1}{2}}$ and $\frac{\Delta{t}}{2}$ , can calculate the derivative
- Last step in algorithm is then:
$$
y_{N+1} = y_N + \Delta{t}\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}
$$
### Midpoint Method Steps
- `Step1: Euler`   $y_{N+\frac{1}{2}} = y_N + \frac{\Delta t}{2}\frac{dy}{dt}\Bigr\rvert_{N}$
- `Step2: Deriv`   $\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}$
- `Step3: Shoot to end`: $y_{N+1} = y_N + \Delta{t}\frac{dy}{dt}\Bigr\rvert_{N+\frac{1}{2}}$
## Runge-Kutta Method
- Instead of shooting to midpoint, shoot to 4 specific points
- RK4 Algorithm
Assume: $\frac{d{y}}{d{t}} = f(y,t)$
Then:
$$
\begin{align*}
k_1 &= \Delta{t}f\left ( y_N, t_N \right )\\
k_2 &= \Delta{t}f\left ( y_N + \frac{k_1}{2}, t_N + \frac{\Delta{t}}{2} \right )\\
k_3 &= \Delta{t}f\left ( y_N + \frac{k_2}{2}, t_N + \frac{\Delta{t}}{2} \right )\\
k_4 &= \Delta{t}f\left ( y_N + k_3, t_N + \Delta{t} \right )\\
y_{N+1} &= y_N + \frac{1}{6} \left ( k_1 +2k_2 +2k_3 +k4 \right )
\end{align*}
$$
# Lecture 2:Lagrange Mechanics I
- Consider ğ‘µ particles
	- Can describe configuration as: $p_N = [x_N y_N z_N]^T$
- Most times, there are constraintsâ€¦
- Can then describe configuration using less parameters (ğ‘› â‰¤ 3ğ‘)
- DOF = n - m
	- ğ‘š is number of constraint equations
## Kinetic Energy
- Total Kinetic Energy of system (ğ‘‡)
- For point particles:
$$
T = \frac{1}{2}\sum_{i=1}^{N}m_i\dot{r}_i^{2}
$$
- What about rigid bodies?
	- Include rotational energy & inertias
$$
T = \frac{1}{2}\sum_{i=1}^{N}m_i\dot{r}_i^{2} + \frac{1}{2}\sum_{i=1}^N I\omega_i^2
$$
## Potential Energy
- Potential Energy from Gravity ($V_{grav}$)
$$V = \sum_{i=1}^{N}m_igh_i$$
- Potential Energy from springs ($V_s$)
$$V = \frac{1}{2}\sum_{i=1}^{N}k_ix_i^{2}$$
## The Lagrangian
$$
L(q,\dot{q}) = T(q,\dot{q}) - V(q)
$$
### Dynamic equation for coordinate $q_i$
$$
\frac{d}{dt}\left ( \frac{\partial L}{\partial \dot{q_i}} \right ) - \frac{\partial L}{\partial {q_i}} = 0
$$
- Repeat for all ğ‘–
- The above gives the EOM for the body
# Lecture 3: Lagrange Mechanics II
- Multibody Systems
## Constraints Revisited
$$\text{DOF} = 3N - m$$
- ğ‘µ is number of bodies and ğ’ is number of constraints
## Multibody systems
- Multibody systems involve multiple rigid bodies
- Each with own COM
- In Lagrange, donâ€™t care about reaction forces or constraint equations
-  Just need to define energy of COM
## Manipulator Equation
- Lagrange EOM are straightforward but tedious to calculate
- Quick side note on motors
$$\frac{d}{dt}\left ( \frac{\partial L}{\partial \dot{q_i}}  \right ) - \frac{\partial L}{\partial q_i} = \tau_i$$
Manipulator Equation
$$
M(q)\ddot{q} + C(q,\dot{q}) + G(q) = \tau
$$
- M = ğ’ Ã— ğ’ Mass Matrix
- C = velocity-product matrix
- G = Gravity term
- $\tau$ = Joint torques

# Lecture 4:3D Kinematics
## Rotating Axes
- consider vector p
- In axes 0 
$$p^0 = \begin{bmatrix}   p_x^0\\   p_y^0   \end{bmatrix}$$
- In axes 1 (rotated by $\psi$) (CCW)
$$
p^0 = \begin{bmatrix}   p_x^1\\   p_y^1   \end{bmatrix}
$$
### Changing axes
$$
\begin{align*}
p^1 &= R_0^1p^0\\
R_0^1 &= \left [ R_1^0 \right ]^{-1}\\
R_0^1 &= \left [ R_1^0 \right ]^{T}
\end{align*}
$$
- Because R is othorgonal you can just take the transpose
## Successive Rotations
Any rigid body attitude can be represented by three rotations. Eg:
### $$R_{x^2,\phi}R_{y^1,\theta}R_{z^0,\psi}$$
- Things to take note of:
	- Rotation is about the new axes
	- Rotation order starts from the right
- Resultant matrix called:
	- Direction Cosine Matrix (DCM)
## Euler Angles
- Euler angles represent attitude about using three numbers:$\textbf{u} = [\phi \hspace{5mm}\theta \hspace{5mm}\psi]^T$
- Need to specify the order
	- Eg. Euler 3-2-1 is
	- Rot about Z, then Y and the X
## Angular Velocity
- Can only add angular velocity vectors in same axis!
- Cannot directly add Euler angle rates ($\dot{\textbf{u}}$) to get $\omega_{Total}$
- We want (inertial): $\omega_T^I = E\dot{u}$
- Or (Body):$\omega_T^B = E'\dot{u}$
## Euler Rates Matrix (E)
- Eg: If we use Euler 3-2-1, E is given by: 
$$
E_{321} = \left [ [R_Z]^T[R_Y]^T\hat{e}_X, [R_Z]^T\hat{e}_Y, \hat{Z} \right ]
$$
- Total angular velocity in Inertial Frame:
$$
\omega_T^I =E\begin{bmatrix}
\dot{\phi} \\
\dot{\theta} \\
\dot{\psi}
\end{bmatrix}
$$
# Lecture 5: 3D Dynamics
## Translational Kinetic Energy
- Translation portion straightforward
$$
T_t = \frac{1}{2}m\dot{r}^T\dot{r}
$$
- With:
$$
\dot{r} = \frac{d}{dt}\left [ [DCM]^Tr^1\right]
$$
### Total Angular Velocity
- Using the inertia: 
$$
T_r = \frac{1}{2}\omega_0^TI^0\omega^0
$$
- Using the body inertia:
$$
T_r = \frac{1}{2}\omega_B^TI^B\omega^B
$$
## Skew Symmetric Property
$$
\omega_B = [R_B^I]^T \dot{R}^I_B = S
$$
#### Add matrice here
# Lecture 6:Generalised Forces
- Lagrangian Mechanics can account for non-conservative forces
	- Called Generalised Forces
- Form:
$$
M(q)\ddot{q} + C(q,\dot{q}) + G(q) = Q
$$
## Derivation of Q vector
$$
Q_i = \sum_{j=1}^m f_j\cdot \frac{\partial r_j}{\partial q_j}
$$
m = number of generalised forces
$f_j$ = Generalised force in inertial coordinates
$r_j$ = Where force acts at






















#
#
#
###
#
#





Examplex
Î¸
m
M
k1
b1
b2
k2
L
u
- Generalised coordinates?
ğ’’ = ğ‘¥ ğœƒ ğ‘‡
- Forces?
ğ’‡ğŸ = âˆ’ğ‘1 áˆ¶ ğ‘¥ Æ¸ ğ’Š
ğ’‡ğŸ = âˆ’ğ‘2 áˆ¶ ğœƒ à·¡ğ’Œ
ğ’‡ğŸ‘ = âˆ’ğ‘¢ Æ¸ ğ’Š
Examplex
Î¸
m
M
k1
b1
b2
k2
L
u
- Positions?
ğ’“ğŸ = ğ‘¥ Æ¸ ğ’Š
ğ’“ğŸ = ğœƒà·¡ğ’Œ
ğ’“ğŸ‘ = ğ‘¥ + ğ¿ğ‘ ğ‘–ğ‘›ğœƒ Æ¸ ğ’Š âˆ’ ğ¿ğ‘ğ‘œğ‘ ğœƒ Æ¸ ğ’‹
Example (x)
- Generalised Force ğ‘¸ğ’™
ğœ•ğ‘Ÿ1
ğœ•ğ‘¥ = 1 Æ¸ğ’Š ğœ•ğ‘Ÿ2
ğœ•ğ‘¥ = 0
ğœ•ğ‘Ÿ3
ğœ•ğ‘¥ = 1 Æ¸ ğ’Š
ğ‘„ğ‘¥ = à·
ğ‘—=1
3
ğ’‡ğ’‹ âˆ™ ğœ•ğ’“ğ’‹
ğœ•ğ‘ğ‘–
= âˆ’ğ‘1 áˆ¶ ğ‘¥ âˆ’ ğ‘¢x
Î¸
m
M
k1
b1
b2
k2
L
u
Example (ğœƒ)
- Generalised Force ğ‘¸ğœƒ
ğœ•ğ‘Ÿ1
ğœ•ğœƒ = 0 ğœ•ğ‘Ÿ2
ğœ•ğœƒ = 1à·¡ğ’Œ
ğœ•ğ‘Ÿ3
ğœ•ğœƒ = ğ¿ğ‘ğ‘œğ‘ ğœƒ Æ¸ ğ’Š + ğ¿ğ‘ ğ‘–ğ‘›ğœƒ Æ¸ ğ’‹
ğ‘„ğœƒ = à·
ğ‘—=1
3
ğ’‡ğ’‹ âˆ™ ğœ•ğ’“ğ’‹
ğœ•ğ‘ğ‘–
= âˆ’ğ‘2 áˆ¶ ğœƒ âˆ’ ğ‘¢ğ¿ğ‘ğ‘œğ‘ ğœƒx
Î¸
m
M
k1
b1
b2
k2
L
u
Finallyâ€¦
ğ‘„ = âˆ’ğ‘1 áˆ¶ ğ‘¥ âˆ’ ğ‘¢
âˆ’ğ‘2 áˆ¶ ğœƒ âˆ’ ğ‘¢ğ¿ğ‘ğ‘œğ‘ ğœƒx
Î¸
m
M
k1
b1
b2
k2
L
u
Exercise: Aero-pendulumy0
z0
x0 x1
y1
z2
x2
y2
F
L1
L2
m
Ïˆ1
Ï†2
- Determine the
generalised force of
the propeller thrust on
the system.
- Assume the thrust
acts perpendicular
to the rod L2.
Exercise: Aero-pendulumy0
z0
x0 x1
y1
z2
x2
y2
F
L1
L2
m
Ïˆ1
Ï†2
Determine rotation matrix, to determine
where force is acting:
ğ‘¹ğŸ
ğŸ =
1 0 0
0 ğ‘ğ‘œğ‘ ğœ‘ ğ‘ ğ‘–ğ‘›ğœ‘
0 âˆ’ğ‘ ğ‘–ğ‘›ğœ‘ ğ‘ğ‘œğ‘ ğœ‘
ğ‘ğ‘œğ‘ ğœ“ ğ‘ ğ‘–ğ‘›ğœ“ 0
âˆ’ğ‘ ğ‘–ğ‘›ğœ“ ğ‘ğ‘œğ‘ ğœ“ 0
0 0 1
= âˆ’
ğ‘ğ‘œğ‘ ğœ“ ğ‘ ğ‘–ğ‘›ğœ“ 0
ğ‘ğ‘œğ‘ ğœ‘ğ‘ ğ‘–ğ‘›ğœ“ ğ‘ğ‘œğ‘ ğœ‘ğ‘ğ‘œğ‘ ğœ“ ğ‘ ğ‘–ğ‘›ğœ‘
ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ ğ‘–ğ‘›ğœ“ âˆ’ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ğ‘œğ‘ ğœ“ ğ‘ğ‘œğ‘ ğœ‘
Exercise: Aero-pendulumy0
z0
x0 x1
y1
z2
x2
y2
F
L1
L2
m
Ïˆ1
Ï†2
Determine position where force is acting
ğ’“ğŸğŸ
ğŸ =
ğ¿1
0
0 ğ’“ğŸğŸ
ğŸ =
0
0
ğ¿2
ğ’“ğŸğŸ
ğŸ = ğ‘¹ğŸ
ğŸ ğ‘‡ğ’“ğŸğŸ
ğŸ + ğ‘¹ğŸ
ğŸ ğ‘‡ğ’“ğŸğŸ
ğŸ =
ğ¿1ğ‘ğ‘œğ‘ ğœ“ + ğ¿2ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ ğ‘–ğ‘›ğœ“
ğ¿1ğ‘ ğ‘–ğ‘›ğœ“ âˆ’ ğ¿2ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ğ‘œğ‘ ğœ“
ğ¿2ğ‘ğ‘œğ‘ ğœ‘
Exercise: Aero-pendulumy0
z0
x0 x1
y1
z2
x2
y2
F
L1
L2
m
Ïˆ1
Ï†2
Determine force as a vector wrt. inertial
ğ‘­ = âˆ’ğ¹ à·œğ’†ğ’š
ğŸ
= âˆ’ğ¹ ğ‘¹ğŸ
ğŸ ğ‘‡ à·œğ’†ğ’š
ğŸ
= ğ¹
ğ‘ğ‘œğ‘ ğœ‘ğ‘ ğ‘–ğ‘›ğœ“
âˆ’ğ‘ğ‘œğ‘ ğœ‘ğ‘ğ‘œğ‘ ğœ“
âˆ’ğ‘ ğ‘–ğ‘›ğœ‘
0
1
0
Exercise: Aero-pendulumy0
z0
x0 x1
y1
z2
x2
y2
F
L1
L2
m
Ïˆ1
Ï†2
Generalised force ğ‘„ğœ“ :
ğ‘„ğœ“ = à·ğ‘—=1
1
ğ’‡ğ’‹ âˆ™ ğœ•ğ’“ğ’‹
ğœ•ğœ“
ğœ•ğ’“02
0
ğœ•ğœ“ =
âˆ’ğ¿1ğ‘ ğ‘–ğ‘›ğœ“ + ğ¿2ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ğ‘œğ‘ ğœ“
ğ¿1ğ‘ğ‘œğ‘ ğœ“ + ğ¿2ğ‘ ğ‘–ğ‘›ğœ‘ğ‘ ğ‘–ğ‘›ğœ“
0
Dot product and some massagingâ€¦
ğ‘„ğœ“ = âˆ’ğ¹ğ¿1ğ‘ğ‘œğ‘ ğœ‘
Constraint Forces
- Admin
- Generalised
Forces
- Constraint forces
Lecture 11:
Generalised
Forces
- Sometimes, you do actually want to
know the reaction forces
- For mechanical design
- Form:
ğ‘´ ğ’’ áˆ· ğ’’ + ğ‘ª ğ’’, áˆ¶ ğ’’ + ğ‘® ğ’’ = ğ‘¨ğ‘»Î»
Constraint
jacobain
Constraint
forces
Example: Pendulum
- What if we want to the reaction
force in the y direction at the
pin?
- Obviously, this system is 1DOF,
and can be modelled using only
Î¸
- Which removes the constraint
force!Î¸
L
m
y
x
Example: Pendulum
- Letâ€™s introduce a redundant
coordinate (y)
- A DOF which we will constrain
to be zero
- So, ğ’’ = ğ‘¦ ğœƒ ğ‘‡
- Now the position of the mass is:
- ğ’“ğ’ = ğ¿ğ‘ ğ‘–ğ‘›ğœƒ
ğ‘¦ âˆ’ ğ¿ğ‘ğ‘œğ‘ ğœƒ
- Then, áˆ¶ ğ’“ğ’ = ğ¿ğ‘ğ‘œğ‘ ğœƒ
áˆ¶
ğ‘¦ + ğ¿ğ‘ ğ‘–ğ‘›ğœƒ áˆ¶ ğœƒ
- Do the energies like usualÎ¸
L
m
Y
Xy
Example: Pendulum
- How do we ensure that it still
moves like it should?
- We need a constraint forces!Î¸
L
m
Y
Xy
- The pin canâ€™t move, so we have a
constraint (h):
â„ = ğ‘¦ = 0
- But how do we use this to
calculate the constraint force?
- We know the velocity should be
zero, so take the derivative with
time: áˆ¶ â„ = áˆ¶ ğ‘¦ = 0
Example: Pendulum
- In general we can write the
velocity constraints as:Î¸
L
m
Y
Xy
áˆ¶
ğ’‰ = ğ‘¨ áˆ¶ğ’’ = 0
- With ğ‘¨ being the Jacobian wrt ğ’’
- We also can then determine the
acceleration constraint as:
ğ‘¨ áˆ·ğ’’ + áˆ¶ ğ‘¨ áˆ¶ğ’’ = 0 = â„
- Solving for áˆ· ğ’’ in the manipulator equation:
áˆ·
ğ’’ = ğ‘´âˆ’ğŸ(âˆ’ğ‘ª âˆ’ ğ‘® + ğ‘©ğ‰ + ğ‘¨ğ‘»ğ€)
Example: Pendulum
- Substitute into the acceleration
constraint to get:Î¸
L
m
Y
Xy
ğ€ = âˆ’ ğ‘¨ğ‘´âˆ’1ğ‘¨ğ‘» âˆ’1(ğ‘¨ğ‘´âˆ’1 ğ‘©ğ‰ âˆ’ ğ‘ª áˆ¶ğ’’ âˆ’ ğ‘® + áˆ¶ ğ‘¨ áˆ¶ğ’’)
- Steps for solving a constrained
system
1. Define constraint
2. Calculate the acceleration of
that constraint
3. Calculate ğ€
4. Use this to solve for áˆ· ğ’’
5. Integrate!
Simulate: ğ’šğŸ = ğŸ, ğœ½ğŸ = ğ…
ğŸ‘
Simulate: ğ’šğŸ = ğŸ, ğœ½ğŸ = ğ…
ğŸ‘
Reaction force (lambda)
Some driftâ€¦
The end
- Next lecture:
- State Space
Revision